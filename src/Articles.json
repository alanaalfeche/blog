{
    "Articles": [
        {   
            "title": "Binary Search Tree",
            "date": "07/05/2020",
            "summary": "Binary Tree is a rooted tree — one vertex is assigned as root, the single access point to the data structure and an ordered tree — every node have at most two children. A binary search tree is organized in a binary tree and follows the <b> <i> binary search tree property </b> </i>: <div style='background-color:#dedede85;padding:20px; margin: 10px 0px;'> Let x be a node in a binary search tree. If y is a node in the left subtree of x, then y.key ≤ x.key. If y is a node in the right subtree of x, then y.key ≥ x.key. Thus for any node x, the keys in the left subtree of x are at most x.key, and the keys in the right subtree of x are at least x.key.</div> By following the left and right child pointers, binary search tree guarantees that it will return the minimum and maximum value of a dynamic set, respectively. If a tree is a complete binary tree — every level,  except possibly the last, is filled, such operations run in O(lg n) worst-case time. But if a tree follows that of a linear chain of n nodes, then basic operations can run in O(n) worst-case time. For a randomly built binary search tree, time is proportional to the height of a tree O(lg n) time on average. See <a href='https://github.com/alanaalfeche/python-sandbox/blob/master/blog_snippets/binary_search_tree.py'> implementation example</a> of insert, delete, and search operations using binary tree. In addition to dictionaries, binary search tree is also an effective data structure for priority queues.",
            "citation": "Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. 2009. Introduction to Algorithms, Third Edition (3rd. ed.). The MIT Press.",
            "tags": ["computer science,", " summary"]
        },
        {   
            "title": "Hash Table",
            "date": "07/04/2020",
            "summary": "Hash table is an effective data structure to implement dictionaries — an abstract data type composed of key-value pairs. If we can afford to allocate an array that has one position for every possible key, a direct-address table is sufficient. Each position or slot in direct-address table corresponds to a key which contains the pointers to elements. But if the size is too large, we can use hash function h(k) to compute the slot from key k. Example of hash functions include division method <i> h(k) = k mod m </i> where m is table size, multiplication method <i> h(k) = [m (kA mod 1)] </i> where A ~ 0.618 as suggested by Knuth, and universal hashing where h(k) is randomly chosen from a family of functions at the beginning of each execution. All hash function however can result to collision because two keys may hash to the same slot. One way to address this problem is by chaining (close addressing) where slot j contains a pointer to the head of a linked list storing all elements that hash to j. Another alternative method is open addressing where all elements occupy the hash table, removing the use of pointers. One common probing technique to find an empty spot for a key is linear probing where it iterates through the array until a free spot is found. While the implementation of a hash table can be daunting, a hash table has O(1) time on average for all basic dictionary operations if implemented properly. Hashing project example <a href='https://github.com/alanaalfeche/java-sandbox/tree/master/JHU.605.620/hashing'> here</a>.",
            "citation": "Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. 2009. Introduction to Algorithms, Third Edition (3rd. ed.). The MIT Press.",
            "tags": ["computer science,", " summary"]
        },
        {
            "title": "Elementary Data Structures",
            "date": "07/03/2020",
            "summary": "Unlike mathematical sets, dynamic sets can be manipulated to grow, shrink, and change over time by an algorithm. In a common implementation of a dynamic set, each element is represented as an object whose attributes e.g. key is tractable with a pointer. Elementary data structures such as stacks, queues, and linked lists can represent finite dynamic sets with pointers. In stacks and queues, the removal of elements is prespecified. While stack follows a last-in-first-out (LIFO) policy, queue follows a first-in-first-out (FIFO) policy. <a href='https://github.com/alanaalfeche/python-sandbox/blob/master/blog_snippets/stack.py'>Stack</a> and <a href='https://github.com/alanaalfeche/python-sandbox/blob/master/blog_snippets/queue.py'>queue</a> can be represented with a simple array or doubly linked list, respectively. Unlike array in which linear order is determined by array indices, the order in linked list is determined by a pointer in each object. Linked list comes in many forms including but not limited to singly-linked, doubly-linked, sorter, unsorted, and circular. While an insert in a doubly-linked list can run in linear time, search can take O(n) in the worst case since it may have to search the entire list: <a href='https://github.com/alanaalfeche/python-sandbox/blob/master/blog_snippets/doubly_linked_list.py'>doubly linked list</a>",
            "citation": "Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. 2009. Introduction to Algorithms, Third Edition (3rd. ed.). The MIT Press.",
            "tags": ["computer science,", " summary"]
        },
        {
            "title": "Bioinformatics",
            "date": "04/29/2020",
            "summary": "Bioinformatics is the collection, management, and analysis of biological information. It is an interdisciplinary field of biology, math, physics, computer science, and medicine. Bioinformatics supports -omics research. The three most common ones are the study of genomics (DNA) which attempt to understand the interaction between genes and genes-environment, transcriptomics (RNA) which reveals mRNA expression level, and proteomics (Protein) which studies protein's structure and function. In bioinformatics, information techniques are applied on the physical chemistry data of molecules to understand and organize data to large-scale: 'bench -> bed'. Besides medical application, bioinformatics can also be used in non-medical field such as energy and environment, agriculture, risk management and mitigation, and forensic science. The increasing advancement of sequencing tools will allow more biological information to be explored. Accompanying to this advancement however are challenges found in data security, data storage, data visualization, and the lack of standard within bioinformatics data.",
            "citation": "https://www.slideshare.net/JTADrexel/bioinformatics-2512758",
            "tags": ["bioinformatics,", " summary"]
        },
        {
            "title": "Proto-oncogenes",
            "date": "04/29/2020",
            "summary": "Cancer cells are generally induced by activated photo-oncogenes — genes that when mutated cause normal cells to become cancer cells. The mutated version of proto-oncogenes is termed “oncogenes” and it disrupts cell regulation by promoting cell proliferation, inhibiting cell differentiation, or halting cell death. So, how does proto-oncogene become oncogene? Oncogene is a result of high expression level of mutations in proto-oncogene. Genetic mechanism that can induce oncogene activation includes: 1) Point mutation, deletion, insertions that leads to a hyperactive gene 2) Point mutation, deletion, insertion in the promoter region that leads to aberrant transcription 3) Gene amplifications events producing extra chromosomal copies of proto-oncogene 4) Chromosomal translocation events that relocate proto-oncogene to a new chromosomal site that leads to higher expression 5) Chromosomal translocations that lead to a fusion between a proto-oncogene and a second gene, which produces a fusion protein with oncogenic activity. It is important to note that cancer is most likely to be a multistep process during which cells acquire a series of mutations that collectively lead to increased proto-oncogene function. Thus, targeting specific oncogene is never enough to defeat cancer due to the complex nature of its formation in the first place.",
            "citation": "Chial, H. (2008) Proto-oncogenes to oncogenes to cancer. Nature Education 1(1):33",
            "tags": ["biology,", " summary"]
        }
    ]
}
